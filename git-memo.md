---
layout: page
title: "git memo"
permalink: /docs/git-memo
---

#　ソフトウェア工学　2024
# UML図について

UML（Unified Modeling Language）は、オブジェクト指向設計で使用される標準的なモデリング言語。UML図にはいくつかの種類があり、システムの異なる側面を視覚的に表現することができる。以下のようなUML図の種類がある。

- **クラス図**: クラスとその関係、属性、メソッドを表す。
- **シーケンス図**: オブジェクト間の相互作用やメッセージのやり取りを時系列に表す。
- **ユースケース図**: システムの機能と、それを利用するアクターを表しす。
- **ステートマシン図**: システムやオブジェクトの状態遷移を表す。


# クラス図について

クラス図は、UMLの図の一種で、システムの静的な構造を表現するツールである。クラス図では、クラス、属性、メソッド、およびクラス間の関係（例えば、継承、関連、依存など）が視覚的に示され、クラス図は、システムのオブジェクト構造を理解しやすくする重要なツールである。
以下は、クラス図の基本的な構成要素。

- **クラス**: システム内のオブジェクトを表し、名前、属性、メソッドを持つ。
- **属性**: クラスのプロパティやデータを表す。
- **メソッド**: クラスの操作や機能を表す。
- **関連**: クラス間の関係を示す（関連、集約、コンポジション、継承など）。

# 開発プロセスについて

## 開発ウォーターフォール型

ウォーターフォール型開発は、システム開発プロセスを一連の順序立てたフェーズに分けるモデル。各フェーズは次のフェーズが始まる前に完了する必要があり、基本的に後戻りはできない。

1. **要件定義**: システムの要件を詳細に定義し、文書化する。
2. **設計**: 要件に基づいてシステムの設計を行う。アーキテクチャ設計と詳細設計に分かれる。
3. **実装**: 設計に基づいてプログラムコードを作成する。
4. **テスト**: 実装されたシステムが要件を満たしているかを確認する。
5. **導入**: システムを実際の運用環境に展開し、利用を開始する。
6. **保守**: システムの運用をサポートし、問題が発生した場合に修正を行う。

**ウォーターフォール型のメリット・デメリット**
プロジェクトの計画が明確で、変更が少ない場合に適している。柔軟性に欠けるため、要件の変化に対応しづらいというデメリットがあります。

## アジャイル型開発

アジャイル開発は、適応的で反復的な開発プロセスです。小規模なチームが短いスプリント（1〜4週間）で機能を開発し、定期的にリリースしていき、保守運用を繰り返し行う。以下がスプリントで行う4つのプロセス。

1. **スプリントプランニング**: スプリントの開始時に行うミーティング
、スプリントの開発内容や進め方を決める。
2. **デイリースクラム**: スプリント期間中に毎日行う15分程度のミーティング、進捗や今日の目標・開発を進めるうえでの課題などを共有する。
3. **スプリントレビュー**: スプリントの最後に行う会議の1つ、今回のスプリントの成果や今後の流れを共有する。
4. **スプリントレトロスペクティブ**: スプリントの最後に行う会議、今回のスプリントに対する評価や反省点を確認し、次回以降に向けた改善点を検討する。

**アジャイル型のメリット**
アジャイル型は、変化の激しい環境や不確実性の高いプロジェクトに適しており、迅速なフィードバックと適応が可能。

## スパイラルモデル

スパイラルモデルは、リスク管理を重視した反復型の開発モデルです。プロジェクトは複数のサイクル（スパイラル）に分割され、各サイクルでリスク評価とともに開発プロセスが進められる。以下がスパイラルモデルの主要な特徴。

1. **リスク評価と軽減**: 各スパイラルの開始時にリスクを特定し、対策を講じる。
2. **反復的なアプローチ**: 要件定義、設計、実装、テストのサイクルを繰り返し、各サイクルでプロジェクトが進化する。
3. **ユーザーのフィードバック**: 各サイクルの終了時にユーザーからのフィードバックを得て、次のサイクルに反映する。
4. **プロジェクトの段階的な進行**: 最初のサイクルでは最も基本的な部分を開発し、以降のサイクルで追加機能や改善を行う。

**スパイラルモデルのメリット**
スパイラルモデルは、特に大規模で複雑なプロジェクトに適しており、リスクを管理しながら進行することができる。


# WBS（Work Breakdown Structure）

WBS（作業分解構造）は、プロジェクトの作業を階層的に分解し、整理するための手法。プロジェクトを小さな作業単位に分割することで、管理が容易になり、進捗の把握がしやすくなること強みである。WBSは、通常ツリー構造で表示され、最上位にプロジェクト全体、その下にフェーズや大きな作業パッケージ、さらにその下に具体的な作業が配置される。
本講義では、受講生が考えるイベントを開催する事を想定し、WBSを作成した。



# GitとGitHubの違い

## Git
Gitは、分散型バージョン管理システムであり、主にソースコードのバージョン管理に使用される。Gitを利用することで、開発者はコードの変更履歴を記録し、異なるバージョン間の統合や差分を管理できる。以下の特徴を持つ。

- **ローカルでの操作が可能**: ネットワークに接続していなくても、全ての操作がローカルで完結する。
- **ブランチ機能**: 異なる作業を並行して進めるためにブランチを活用できる。
- **高速な処理**: 変更の確認やコミットの操作が高速。

## GitHub
GitHubは、Gitリポジトリをホスティングするためのウェブサービスである。GitHubはGitをベースにしており、リモートリポジトリとして機能する。GitHubは、ソースコードの管理に加え、以下のような機能を提供する。

- **リポジトリのホスティング**: リモートでコードを共有し、他の開発者と協力して開発することができる。
- **プルリクエスト**: コードの変更を提案し、レビューを受けるための機能であり、チームでのコードレビューが効率的に行える。
- **イシュー管理**: バグ報告やタスクのトラッキングを行うための機能。
- **プロジェクト管理ツール**: カンバンボードなど、プロジェクト管理を支援するツールがある。

# GitHubフロー

GitHubフローは、GitHubを利用した開発プロセスの一つで、以下が基本的なワークフローである。

1. **ブランチ作成**: 新しい機能やバグ修正のために、メインブランチ（通常は`main`または`master`）から新しいブランチを作成する。ブランチ名は、作業内容がわかりやすいものにするとよい（例: `feature/new-feature`、`fix/bug-fix`）。

2. **開発とコミット**: 作成したブランチで開発を行い、変更をコミットしする。コミットメッセージは変更内容を明確に記述するべき。

3. **プルリクエスト作成**: 変更が完了したら、GitHub上でプルリクエストを作成する。プルリクエストには変更内容の説明や影響範囲などを記述し、レビューを依頼します。

4. **コードレビュー**: チームメンバーがプルリクエストをレビューし、必要に応じてフィードバックを行う。修正が必要な場合は、フィードバックに基づいてブランチで修正を行い、再度コミットする。


5. **マージ**: レビューが完了し、承認されたら、プルリクエストをメインブランチにマージする。通常、マージ後にはブランチを削除する（しなくてもどちらでもよいが、した方が整理整頓される）。

（本講義では、全て一人での開発であったため、プルリクエスト～マージを一人で行った）

6. **デプロイ**: メインブランチへのマージ後、変更が適用され、必要に応じてデプロイ作業が行われる。


GitHubフローは、メインブランチを常に安定した状態に保ちながら、新しい機能の追加やバグ修正を行うために欠かせないプロセスである。







## githubでの主なコマンド




## リモートリポジトリの操作

### git clone
- **説明**: リモートリポジトリをローカルにコピーする。
- **例**:
  ```sh
  git clone <repository-url>
  ```

### git pull
- **説明**: リモートリポジトリの最新の変更を取得し、ローカルブランチにマージする。
- **例**:
  ```sh
  git pull
  ```

### git push
- **説明**: ローカルの変更をリモートリポジトリにアップロードする。
- **例**:
  ```sh
  git push
  ```

### git request-pull
- **説明**: プルリクエストを作成し、変更の取り込みを依頼する。
- **例**:
  ```sh
  git request-pull <start-commit> <repository-url> <end-commit>
  ```
  

### git remote
- **説明**: リモートリポジトリの設定や管理を行う。
- **例**:
  ```sh
  git remote add <name> <url>
  git remote -v
  ```

## ブランチ操作

### git branch
- **説明**: 新しいブランチを作成する。
- **例**:
  ```sh
  git branch <new-branch-name>
  ```

### git checkout
- **説明**: ブランチの切り替えを行う。
- **例**:
  ```sh
  git checkout <branch-name>
  ```

### git merge
- **説明**: 他のブランチを現在のブランチにマージする。`--ff-only` オプションを使用すると、変更のない統合先ブランチにのみマージする。
- **例**:
  ```sh
  git merge <branch-name>
  git merge --ff-only <branch-name>
  ```

## ステージングとコミット

### git add
- **説明**: ファイルをステージングエリアに追加する。
- **例**:
  ```sh
  git add <file-path>
  ```

### git commit
- **説明**: ステージングエリアの変更をコミットする。
- **例**:
  ```sh
  git commit -m "commit message"
  ```

## 初期設定とステータス

### git init
- **説明**: 新しい Git リポジトリを初期化する。
- **例**:
  ```sh
  git init
  ```

### git status
- **説明**: ワークツリーとステージングエリアの状態を表示する。
- **例**:
  ```sh
  git status
  ```

### git config
- **説明**: Git の設定を確認・変更する。
- **例**:
  ```sh
  git config --global user.name "Your Name"
  git config --global user.email "your.email@example.com"
  ```
  ## コミットの修正

### git commit --amend --no-edit
- **説明**: 最新のコミットを修正する際に、メッセージを変更せずに内容のみ修正する。
- **例**:
  ```sh
  git commit --amend --no-edit
  ```

  ## コミットのリセットと打ち消し

### git reset
- **説明**: コミットのリセットを行う。`--soft`, `--mixed`, `--hard` のオプションを使用してリセットの範囲を指定する。
- **例**:
  ```sh
  git reset --soft <commit-hash>
  git reset --mixed <commit-hash>
  git reset --hard <commit-hash>
  ```

### git revert
- **説明**: 指定したコミットの変更を打ち消す新しいコミットを作成する。
- **例**:
  ```sh
  git revert <commit-hash>
  ```

## ファイルとインデックス情報の削除

### git rm
- **説明**: ファイルを削除し、ステージングエリアからも削除する。
- **例**:
  ```sh
  git rm <file-path>
  ```

## 過去のコミットやファイルの復元

### git checkout
- **説明**: 削除されたファイルを復旧したり、過去のコミットを復元するために使用する。ステージングエリアにある変更を元に戻す。
- **例**:
  ```sh
  git checkout <branch-name>
  git checkout -- <file-path>
  ```

## ログと差分

### git log
- **説明**: コミットの履歴を表示する。`--oneline` オプションを使用すると、コミットメッセージの1行のみの一覧を表示する。
- **例**:
  ```sh
  git log
  git log --oneline
  ```

### git diff
- **説明**: ファイルの差分を表示する。
- **例**:
  ```sh
  git diff
  ```
```

